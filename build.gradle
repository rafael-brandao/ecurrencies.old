import org.apache.tools.ant.filters.ReplaceTokens
import org.apache.tools.ant.taskdefs.condition.Os

buildscript {
    repositories {
        mavenCentral()
    }
    dependencies {
        classpath 'ws.antonov.gradle.plugins:gradle-plugin-protobuf:0.7'
    }
}

ext {
    jvm = org.gradle.internal.jvm.Jvm.current()
    javaVersion = JavaVersion.current()
    assert javaVersion.java7: "Must use a Java 7 compatible JVM to perform this build. Current JVM is ${jvm}"

    protobufProjects = [] as Set
    javaProjects = [] as Set
    scalaProjects = [] as Set

    distributionProjects = [] as Set

    apply from: "$rootDir/gradle/subprojects.gradle"
}

allprojects {

    version = rootProject.version

    ext {
        versionBindings = project.ext.properties.findAll { it.key ==~ /^[\w]+Version$/ }
    }

    apply from: "$rootDir/gradle/naming.gradle"
    apply plugin: 'eclipse'
    apply plugin: 'idea'

    afterEvaluate {
        eclipse.project.name = artifactId
    }
    repositories {
        mavenCentral()
        mavenRepo url: 'https://oss.sonatype.org/content/groups/public/'
        mavenRepo url: 'http://repo.spray.io/'
    }
    configurations.all*.resolutionStrategy { force "${scalaGroup}:scala-library:${scalaVersion}" }

    afterEvaluate {
        tasks.withType(Copy) {
            filter(ReplaceTokens, tokens: project.ext.properties)
        }
    }
}

configure(javaProjects) {
    apply plugin: 'java'

    sourceCompatibility = javaVersion
    targetCompatibility = javaVersion

    jar {
        manifest.attributes << ['Implementation-Title': artifactId]
        manifest.attributes << ['Implementation-Version': version]

        from("$rootDir/src/dist") {
            include "license.txt"
            include "notice.txt"
            into "META-INF"
            expand(copyright: new Date().format('yyyy'), version: version)
        }
    }

    dependencies { testCompile "${junitGroup}:junit:${junitVersion}" }

    test {
        enableAssertions = true
        jvmArgs '-Xms256m', '-Xmx512m'
        testLogging {
            minGranularity = 3
            showStandardStreams = true
            exceptionFormat 'full'
            events 'failed'
            info.events 'passed'
            debug.events 'started'
            stackTraceFilters 'groovy', 'entry_point', 'truncate'
        }
    }

    tasks.withType(JavaCompile) {
        it.options.encoding = 'UTF-8'
    }

    afterEvaluate { 
        archivesBaseName = artifactId

        task sourcesJar(type: Jar, dependsOn: classes) {
            classifier = "sources"
            from sourceSets.main.allSource.srcDirs
        }

        artifacts { archives sourcesJar }
    }
}

configure(protobufProjects) {
    apply plugin: 'protobuf'

    dependencies {
        compile "${protobufGroup}:protobuf-java:${protobufVersion}"
    }

    /*
     * Amazingly stupid hack to export generated classes in idea ide
     *
     * This happens because idea ide prevents any generated source dir inside build 
     * dir to be considered a valid source dir.
     *
     */
    ext.protoGeneratedSources = file("${projectDir}/generated-sources")
    sourceSets.main.java { srcDirs += protoGeneratedSources }

    generateProto.destinationDir = protoGeneratedSources
    clean.dependsOn('cleanGenerateProto')
}

configure(scalaProjects) {
    apply plugin: 'scala'

    dependencies {
        compile "$scalaGroup:scala-library:$scalaVersion"
        scalaTools "$scalaGroup:scala-compiler:$scalaVersion"
        testCompile "${scalaTestGroup}:scalatest_${scalaTestScalaVersion}:${scalaTestVersion}",
                "${junitGroup}:junit:${junitVersion}"
    }

    tasks.withType(ScalaCompile).each {
        it.options.encoding = 'UTF-8'
        it.scalaCompileOptions.with {
            additionalParameters = ['-feature', '-Ywarn-all']
            deprecation = true
            encoding = 'UTF-8'
            useAnt = false
        }
    }
}

configure(javaProjects - protobufProjects) {
    def javaCompileTasks = tasks.withType(JavaCompile)
    def scalaCompileTasks = tasks.withType(ScalaCompile)

    (javaCompileTasks + scalaCompileTasks).each {
        it.options.compilerArgs = ['-Xlint:all', '-Werror']
    }
}

configure(distributionProjects) {

    ext {

        JAVA_OPTS = '-Xms1024M -Xmx1024M -Xss1M -XX:MaxPermSize=256M -XX:+UseParallelGC'

        if (!project.hasProperty('env'))
            env = 'default'

        srcDir = "$projectDir/src/akka/dist"
        outputDir = "$buildDir/akka/dist/$env"

        configFileName = "application.${env}.conf"
        configFile = "$srcDir/config/$configFileName"
        configOutputDir = "$outputDir/config"
        deployDir = "$outputDir/deploy"
        libDir = "$outputDir/lib"
        akkaLibDir = "$libDir/akka"
        scriptsInputDir = "$srcDir/init-scripts"
        scriptsOutputDir = "$outputDir/bin"

        deployFilters = []

        bootableClass = ""
    }

    configurations.all*.exclude group: 'org.parboiled', module: 'parboiled-scala_2.10.0-RC5'

    task generateConfig(type: Copy, group: 'akka') {
        def configFile = file(project.ext.configFile)
        from configFile
        into configOutputDir
        rename(configFile.name, "application.conf")
    }

    task generateScripts(type: Copy, group: 'akka') {
        from scriptsInputDir
        into scriptsOutputDir
    }

    task distribution(group: 'akka') {

        dependsOn check
        dependsOn generateScripts
        dependsOn generateConfig

        build.dependsOn distribution

        doLast {
            def deployed
            configurations.compile.files.each { file ->
                deployed = false
                deployFilters.each {
                    if (file.name =~ it) {
                        copy {
                            from file
                            into deployDir
                        }
                        deployed = true
                    }
                }
                if (deployed)
                    return

                if (file.name =~ /scala-library/)
                    copy {
                        from file
                        into libDir
                    }
                else
                    copy {
                        from file
                        into akkaLibDir
                    }
            }
            copy {
                from file("$libsDir/$archivesBaseName-${version}.jar")
                into deployDir
            }
        }
    }

    task execute(type: Exec, group: 'akka') {
        dependsOn build

        logging.captureStandardOutput(LogLevel.LIFECYCLE)

        doFirst {

            assert project.ext.bootableClass != ""
            assert file(outputDir).isDirectory()

            workingDir = file(scriptsOutputDir)

            if (Os.isFamily(Os.FAMILY_WINDOWS)) {
                commandLine 'cmd', '/c', 'start', 'akka.bat', bootableClass
            } else {
                throw new GradleException("Non windows env execution is not supported yet")
            }
        }
    }
}