import org.apache.tools.ant.filters.ReplaceTokens

buildscript {
    repositories { mavenRepo url: 'http://repo.springsource.org/plugins-release' }
    dependencies { classpath("org.springframework.build.gradle:propdeps-plugin:0.0.2") }
}

ext {
    jvm = org.gradle.internal.jvm.Jvm.current()
    javaVersion = JavaVersion.current()
    assert javaVersion.java7 : "Must use a Java 7 compatible JVM to perform this build. Current JVM is ${jvm}"

    protobufProjects = []
    javaProjects = []
    scalaProjects = []

    distributionProjects = []

    apply from: "$rootDir/gradle/subprojects.gradle"
}

allprojects {

    version = rootProject.version

    ext {
        versionBindings = project.ext.properties.findAll{ it.key ==~ /^[\w]+Version$/ }
    }

    apply from: "$rootDir/gradle/naming.gradle"
    apply plugin: 'eclipse'

    afterEvaluate {
        eclipse.project.name = artifactId
    }
    repositories {
        mavenCentral()
        mavenRepo url: 'https://oss.sonatype.org/content/groups/public/'
        mavenRepo url: 'http://repo.spray.io/'
    }
    configurations.all*.resolutionStrategy { force "${scalaGroup}:scala-library:${scalaVersion}" }

    afterEvaluate {
        tasks.withType(Copy) {
            filter(ReplaceTokens, tokens: project.ext.properties)
        }
    }
}

configure(javaProjects) {
    apply plugin: 'java'

    sourceCompatibility = javaVersion
    targetCompatibility = javaVersion

    jar {
        manifest.attributes << ['Implementation-Title':artifactId]
        manifest.attributes << ['Implementation-Version':version]

        from("$rootDir/src/dist") {
            include "license.txt"
            include "notice.txt"
            into "META-INF"
            expand(copyright: new Date().format('yyyy'), version: version)
        }
    }

    dependencies { testCompile "${junitGroup}:junit:${junitVersion}" }

    test {
        enableAssertions = true
        jvmArgs '-Xms256m', '-Xmx512m'
        testLogging {
            minGranularity = 3
            showStandardStreams = true
            exceptionFormat 'full'
            events 'failed'
            info.events 'passed'
            debug.events 'started'
            stackTraceFilters 'groovy', 'entry_point', 'truncate'
        }
    }

    task sourcesJar(type: Jar, dependsOn:classes) {
        classifier = "sources"
        from sourceSets.main.allSource.srcDirs
    }

    artifacts { archives sourcesJar }

    tasks.withType(JavaCompile) {
        it.options.encoding = 'UTF-8'
    }

    afterEvaluate { archivesBaseName = artifactId }
}

configure(protobufProjects) {
    ext {
        protobufOutputDir = file("${project.buildDir}/protobuf")
        protobufJavaOutputDir = file("${protobufOutputDir}/java")
        protobufResourcesOutputDir = file("${protobufOutputDir}/resources")
    }


    sourceSets {
        main {
            java { srcDirs += "${protobufOutputDir}/java" }
            resources { srcDirs += "${protobufOutputDir}/resources" }
        }
    }


    apply from: "$rootDir/gradle/protobuf.gradle"
}

configure(scalaProjects) {
    apply plugin: 'scala'

    dependencies {
        compile    "$scalaGroup:scala-library:$scalaVersion"
        scalaTools "$scalaGroup:scala-compiler:$scalaVersion"
        testCompile "${scalaTestGroup}:scalatest_${scalaVersion}:${scalaTestVersion}",
                "${junitGroup}:junit:${junitVersion}"
    }

    tasks.withType(ScalaCompile).each {
        it.options.encoding = 'UTF-8'
        it.scalaCompileOptions.with {
            encoding = 'UTF-8'
            useAnt   = false
        }
    }
}

configure(javaProjects - protobufProjects) {
    def javaCompileTasks = tasks.withType(JavaCompile)
    def scalaCompileTasks = tasks.withType(ScalaCompile)

    (javaCompileTasks + scalaCompileTasks).each {
        it.options.compilerArgs = ['-Xlint:all', '-Werror']
    }
}

configure(distributionProjects) {

    ext {

        JAVA_OPTS = '-Xms1024M -Xmx1024M -Xss1M -XX:MaxPermSize=256M -XX:+UseParallelGC'

        if(!project.hasProperty('env'))
            env = 'default'

        srcDir = "${projectDir.path}/src/akka/dist"
        outputDir = "${buildDir.path}/akka/dist/$env"

        configFileName = "application.${env}.conf"
        configFile = "$srcDir/config/$configFileName"
        configOutputDir = "$outputDir/config"
        deployDir = "$outputDir/deploy"
        libDir = "$outputDir/lib"
        akkaLibDir = "$libDir/akka"
        scriptsInputDir = "$srcDir/init-scripts"
        scriptsOutputDir = "$outputDir/bin"

        deployFilters = []
    }

    configurations.all*.exclude group: 'org.parboiled' , module : 'parboiled-scala_2.10.0-RC5'

    task generateConfig(type: Copy){
        def configFile = file(project.ext.configFile)
        from configFile
        into configOutputDir
        rename(configFile.name, "application.conf")
    }

    task generateScripts(type:Copy) {
        from scriptsInputDir
        into scriptsOutputDir
    }

    task distribution {
        dependsOn generateConfig
        dependsOn generateScripts

        build.dependsOn distribution

        doLast {
            def deployed
            configurations.compile.files.each { file ->
                deployed = false
                deployFilters.each {
                    if(file.name =~ it) {
                        copy {
                            from file
                            into deployDir
                        }
                        deployed = true
                    }
                }
                if(deployed) return

                if(file.name =~ /scala-library/)
                    copy {
                        from file
                        into libDir
                    }
                else
                    copy {
                        from file
                        into akkaLibDir
                    }
            }
        }
    }
}